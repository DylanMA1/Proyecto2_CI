package CUP;

import java_cup.runtime.Symbol;

// Declaración de tokens
terminal INTEGER, FLOAT, BOOL, CHAR, STRING, INT_LITERAL, FLOAT_LITERAL, CHAR_LITERAL, STRING_LITERAL;
terminal TRUE, FALSE;
terminal OPEN_BLOCK, CLOSE_BLOCK, OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN;
terminal ASSIGN, END_STATEMENT;
terminal PLUS, MINUS, MULTIPLY, DIVIDE, MODULO, POWER;
terminal INCREMENT, DECREMENT;
terminal LESS_THAN, LESS_EQUAL, GREATER_THAN, GREATER_EQUAL, EQUAL, NOT_EQUAL;
terminal AND, OR, NOT;
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT;
terminal IDENTIFIER, MAIN, PRINT, READ, COLON, COMMA;
terminal BOOL_LITERAL;

// Declaración de no terminales
non terminal program, expression, funciones, funcion, encabezadoFunc, main;
non terminal parametros, paramAux, parametro, bloque, tipos, sentencias, sentencia;
non terminal creacion, creacionAsign, asignacion, literales, arreglo, accesoArreglo;
non terminal asignacionArreglo, llamadaFuncion, argumentos, estructuraControl;
non terminal ifElse, while, for, switch, casos, caso, io, operadorAritmetico, operadorRelacional;
non terminal operadorLogico, operadorUnario, termino, booleano;
non terminal expressionLogica, expressionRelacional, expressionAritmetica, expressionUnaria;

// Precedencia y asociatividad
precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL;
precedence left LESS_THAN, LESS_EQUAL, GREATER_THAN, GREATER_EQUAL;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, MODULO;
precedence right POWER;
precedence right NOT;
precedence right INCREMENT, DECREMENT;

// Símbolo inicial
start with program;

// Reglas de producción
program ::= main funciones | funciones main;

funciones ::= funcion
           | funciones funcion;

funcion ::= encabezadoFunc bloque;

encabezadoFunc ::= tipos IDENTIFIER parametros;

main ::= MAIN OPEN_PAREN CLOSE_PAREN bloque;

parametros ::= OPEN_PAREN CLOSE_PAREN
             | OPEN_PAREN paramAux CLOSE_PAREN;

paramAux ::= parametro
           | paramAux COMMA parametro;

parametro ::= tipos IDENTIFIER;

bloque ::= OPEN_BLOCK sentencias CLOSE_BLOCK;

tipos ::= INTEGER
       | FLOAT
       | BOOL
       | CHAR
       | STRING;

sentencias ::= sentencia
             | sentencias sentencia;

sentencia ::= creacion
            | creacionAsign
            | asignacion
            | llamadaFuncion
            | estructuraControl
            | io
            | arreglo
            | asignacionArreglo;

creacion ::= tipos IDENTIFIER END_STATEMENT;

creacionAsign ::= tipos IDENTIFIER ASSIGN expression END_STATEMENT;

asignacion ::= IDENTIFIER ASSIGN expression END_STATEMENT;

literales ::= INT_LITERAL
            | FLOAT_LITERAL
            | booleano
            | STRING_LITERAL
            | CHAR_LITERAL;

arreglo ::= tipos IDENTIFIER OPEN_BRACKET INT_LITERAL CLOSE_BRACKET END_STATEMENT;

accesoArreglo ::= IDENTIFIER OPEN_BRACKET expression CLOSE_BRACKET;

asignacionArreglo ::= accesoArreglo ASSIGN expression END_STATEMENT;

llamadaFuncion ::= IDENTIFIER OPEN_PAREN argumentos CLOSE_PAREN END_STATEMENT
                 | IDENTIFIER OPEN_PAREN CLOSE_PAREN END_STATEMENT;

argumentos ::= expression
             | argumentos COMMA expression;

estructuraControl ::= ifElse
                    | while
                    | for
                    | switch;

ifElse ::= IF OPEN_PAREN expression CLOSE_PAREN bloque ELSE bloque
         | IF OPEN_PAREN expression CLOSE_PAREN bloque;

while ::= WHILE OPEN_PAREN expression CLOSE_PAREN bloque;

for ::= FOR OPEN_PAREN asignacion COMMA expression COMMA asignacion CLOSE_PAREN bloque;

switch ::= SWITCH OPEN_PAREN expression CLOSE_PAREN OPEN_BLOCK casos CLOSE_BLOCK;

casos ::= caso
        | casos caso;

caso ::= CASE expression COLON sentencias
       | DEFAULT COLON sentencias;

io ::= PRINT OPEN_PAREN expression CLOSE_PAREN END_STATEMENT
    | READ OPEN_PAREN IDENTIFIER CLOSE_PAREN END_STATEMENT;

operadorAritmetico ::= PLUS | MINUS | DIVIDE | MULTIPLY | MODULO | POWER;
operadorRelacional ::= LESS_THAN | LESS_EQUAL | GREATER_THAN | GREATER_EQUAL | EQUAL | NOT_EQUAL;
operadorLogico ::= AND | OR | NOT;
operadorUnario ::= INCREMENT | DECREMENT;

termino ::= IDENTIFIER
          | literales
          | llamadaFuncion
          | accesoArreglo
          | OPEN_PAREN expression CLOSE_PAREN;

booleano ::= BOOL_LITERAL | TRUE | FALSE;

// Declaración inicial
expression ::= expressionLogica;

expressionLogica ::= expressionRelacional
                   | expressionLogica operadorLogico expressionRelacional;

expressionRelacional ::= expressionAritmetica
                       | expressionRelacional operadorRelacional expressionAritmetica;

expressionAritmetica ::= expressionUnaria
                       | expressionAritmetica operadorAritmetico expressionUnaria;

expressionUnaria ::= operadorUnario termino
                   | termino;

// Manejo de errores
//expression ::= error {: System.err.println("Error en la expresión."); :};
termino ::= error {: System.err.println("Error en el término."); :};
